[{"authors":null,"categories":["English"],"content":"eurolig proporciona un kit de herramientas para obtener y analizar datos de la Euroliga. El paquete está diseñado principalmente para trabajar con dos tipos de datos de baloncesto: datos jugada a jugada y datos de localización de tiros. A pesar de que la primera temporada de la Euroliga fue en 2l 2000, los datos jugada a jugada y de localización de tiros solo están disponibles desde la temporada 2007/2008. Este artículo introduce la nueva version del paquete (0.4.0) y muestra cómo puede ser usado para realizar algunos análisis sencillos.\nCambios en la nueva versión Si ya habías usado o conocías eurolig de mi entrada anterior, te darás cuenta de que hay bastantes cambios y nuevas funcionalidades. La versión anterior de eurolig (0.0.0.900) estaba aún muy cruda y en su fase más experimental. Para la nueva versión (0.4.0) he añadido mucha más funcionalidad y documentación básica.\nLos cambios más importantes son:\n camelCase para nombres de funciones (en lugar de snake_case).\n He eliminado la función plot_heatmap() para producir heatmaps de los patrones de asistencias.\n Los data frames de datos jugada a jugada contienen variables distintas.\n  Aunque hay bastantes cambios no he mantenido funciones viejas en esta nueva versión porque creo que no hay mucha gente usando el paquete. Código antiguo seguramente no funcionará con esta nueva versión. No obstante, adaptar el código antiguo para la nueva versión debería de ser bastante sencillo.\n Paquetes necesarios Necesitarás instalar el paquete eurolig desde su repositorio en GitHub:\n# install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;solmos/eurolig\u0026quot;) Además de eurolig, los siguientes paquetes son necesarios para reproducir esta entrada:\nlibrary(eurolig) library(dplyr) library(ggplot2)  Obtener los datos Conjuntos de datos Varios conjuntos de datos van incluídos en el paquete. Puedes ver una lista con:\ndata(package = \u0026quot;eurolig\u0026quot;) Los conjuntos de datos samplepbp y sampleshots contienen datos ejemplo de datos jugada a jugada y de localización de tiro, respectivamente.\nUn conjunto de datos bastante útil es gameresults. Contiene todos los resultados de todos los partidos disputados en la Euroliga desde la temporada 2001/2002 hasta la temporada 2018/2019. Como podrás ver en la siguiente sección, este conjunto de datos puede ser útil para encontrar los partidos para los que quieres obtener datos.\nFinalmente, si necesitas encontrar nombres o códigos de equipos, el conjunto de datos teaminfo puede ser útil.\n Funciones extract Funciones que obtienen datos a traves de la API de la web de la Euroliga empiezan con el verbo extract. Necesitarás estar conectado a internet para que estas funciones funcionen.\nLas principales funciones para obtener datos son:\n extractPbp() para datos jugada a jugada.\n extractShots() para datos de localización de tiros.\n  Estas funciones solo pueden obtener datos de un sólo partido. Esto quiere decir que si necesitas conseguir datos para varios partidos deberás iterar la función para todos los partidos de interés. Nótese, sin embargo, que el archivo robot.txt de la Euroliga pide que se esperen 15 segundos (!) entre cada petición. Ten esto en cuenta al realizar un gran número de peticiones.\nCada partido se identifica con una combinación única de temporada y código de partido. Para indicar a las funciones extract de qué partido queremos obtener datos necesitamos introducir como argumentos el código y la temporada correspondiente.\nVamos a encontrar, por ejemplo, los partidos de la temporada 2018/2019 con el mayor número de puntos totales:\ngames \u0026lt;- gameresults %\u0026gt;% filter(season == 2018) %\u0026gt;% mutate(total_points = points_home + points_away) %\u0026gt;% arrange(desc(total_points)) head(games) ## # A tibble: 6 x 14 ## season phase round_name team_home points_home team_away points_away ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; ## 1 2018 RS Round 21 Herbalif… 104 AX Arman… 106 ## 2 2018 RS Round 16 AX Arman… 111 Buducnos… 94 ## 3 2018 RS Round 1 Real Mad… 109 Darussaf… 93 ## 4 2018 RS Round 4 Herbalif… 91 CSKA Mos… 106 ## 5 2018 RS Round 8 CSKA Mos… 99 Zalgiris… 97 ## 6 2018 RS Round 25 CSKA Mos… 101 AX Arman… 95 ## # … with 7 more variables: game_code \u0026lt;int\u0026gt;, date \u0026lt;chr\u0026gt;, round_code \u0026lt;int\u0026gt;, ## # game_url \u0026lt;chr\u0026gt;, team_code_home \u0026lt;chr\u0026gt;, team_code_away \u0026lt;chr\u0026gt;, ## # total_points \u0026lt;int\u0026gt; Podemos comprobar que el partido con mayor puntuación fue el disputado entre el Herbalife Gran Canaria y el AX Armani Exchange Olimpia Milan con 210 puntos totales. La temporada y código que identifican este partido son:\ngames$season[1] ## [1] 2018 games$game_code[1] ## [1] 168 Podemos obtener datos de localización de tiro y de jugada a jugada para este partido introduciendo estos valores como argumentos en extractShots() y extractPbp():\ngame_shots \u0026lt;- extractShots(game_code = 168, season = 2018) game_pbp \u0026lt;- extractPbp(168, 2018) Si quisiésemos encontrar partidos para la temporada actual (no incluida en gameresults) tenemos dos opciones: mirar el código del partido en la url del partido o usar extractResults().\n  Análisis de datos jugada a jugada Los datos jugada a jugada contienen mucha información que no está en las estadísticas del boxscore tradicional. En el análisis que sigue voy a mostrar cómo utilizar eurolig para encontrar la siguiente información a partir de los datos jugada a jugada:\n Mas-Menos (+/-) para uno o más jugadores.\n Estadísticas On/Off para uno o más jugadores.\n Patrones de asistencias dentro de un equipo.\n  Para estos análisis voy a utilizar el conjunto de datos samplepbp que contiene los datos jugada a jugada de los cuatro partidos de la Final Four de la Euroliga 2018/2019:\ndata(\u0026quot;samplepbp\u0026quot;) glimpse(samplepbp) ## Observations: 2,121 ## Variables: 29 ## $ season \u0026lt;int\u0026gt; 2018, 2018, 2018, 2018, 2018, 2018, 2018, 2018, 2… ## $ game_code \u0026lt;int\u0026gt; 257, 257, 257, 257, 257, 257, 257, 257, 257, 257,… ## $ play_number \u0026lt;int\u0026gt; 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 1… ## $ team_code \u0026lt;chr\u0026gt; NA, \u0026quot;ULK\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;IS… ## $ player_name \u0026lt;chr\u0026gt; NA, \u0026quot;DUVERIOGLU, AHMET\u0026quot;, \u0026quot;DUNSTON, BRYANT\u0026quot;, \u0026quot;MUHA… ## $ play_type \u0026lt;chr\u0026gt; \u0026quot;BP\u0026quot;, \u0026quot;TPOFF\u0026quot;, \u0026quot;TPOFF\u0026quot;, \u0026quot;2FGM\u0026quot;, \u0026quot;2FGA\u0026quot;, \u0026quot;RBLK\u0026quot;, \u0026quot;… ## $ time_remaining \u0026lt;chr\u0026gt; \u0026quot;10:00\u0026quot;, \u0026quot;09:59\u0026quot;, \u0026quot;09:59\u0026quot;, \u0026quot;09:42\u0026quot;, \u0026quot;09:19\u0026quot;, \u0026quot;09:… ## $ quarter \u0026lt;dbl\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ points_home \u0026lt;dbl\u0026gt; 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5… ## $ points_away \u0026lt;dbl\u0026gt; 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2… ## $ play_info \u0026lt;chr\u0026gt; \u0026quot;Begin Period\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;Two Pointer (1/1 - 2 pt… ## $ seconds \u0026lt;dbl\u0026gt; 0, 1, 1, 18, 41, 41, 44, 45, 47, 56, 56, 67, 68, … ## $ home_team \u0026lt;chr\u0026gt; \u0026quot;Fenerbahce Beko Istanbul\u0026quot;, \u0026quot;Fenerbahce Beko Ista… ## $ away_team \u0026lt;chr\u0026gt; \u0026quot;Anadolu Efes Istanbul\u0026quot;, \u0026quot;Anadolu Efes Istanbul\u0026quot;,… ## $ home \u0026lt;lgl\u0026gt; NA, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE,… ## $ team_name \u0026lt;chr\u0026gt; NA, \u0026quot;Fenerbahce Beko Istanbul\u0026quot;, \u0026quot;Anadolu Efes Ist… ## $ last_ft \u0026lt;lgl\u0026gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, … ## $ and1 \u0026lt;lgl\u0026gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, … ## $ home_player1 \u0026lt;chr\u0026gt; \u0026quot;GREEN, ERICK\u0026quot;, \u0026quot;GREEN, ERICK\u0026quot;, \u0026quot;GREEN, ERICK\u0026quot;, \u0026quot;… ## $ home_player2 \u0026lt;chr\u0026gt; \u0026quot;MELLI, NICOLO\u0026quot;, \u0026quot;MELLI, NICOLO\u0026quot;, \u0026quot;MELLI, NICOLO\u0026quot;… ## $ home_player3 \u0026lt;chr\u0026gt; \u0026quot;GUDURIC, MARKO\u0026quot;, \u0026quot;GUDURIC, MARKO\u0026quot;, \u0026quot;GUDURIC, MAR… ## $ home_player4 \u0026lt;chr\u0026gt; \u0026quot;MUHAMMED, ALI\u0026quot;, \u0026quot;MUHAMMED, ALI\u0026quot;, \u0026quot;MUHAMMED, ALI\u0026quot;… ## $ home_player5 \u0026lt;chr\u0026gt; \u0026quot;DUVERIOGLU, AHMET\u0026quot;, \u0026quot;DUVERIOGLU, AHMET\u0026quot;, \u0026quot;DUVERI… ## $ away_player1 \u0026lt;chr\u0026gt; \u0026quot;LARKIN, SHANE\u0026quot;, \u0026quot;LARKIN, SHANE\u0026quot;, \u0026quot;LARKIN, SHANE\u0026quot;… ## $ away_player2 \u0026lt;chr\u0026gt; \u0026quot;MOERMAN, ADRIEN\u0026quot;, \u0026quot;MOERMAN, ADRIEN\u0026quot;, \u0026quot;MOERMAN, A… ## $ away_player3 \u0026lt;chr\u0026gt; \u0026quot;MICIC, VASILIJE\u0026quot;, \u0026quot;MICIC, VASILIJE\u0026quot;, \u0026quot;MICIC, VAS… ## $ away_player4 \u0026lt;chr\u0026gt; \u0026quot;DUNSTON, BRYANT\u0026quot;, \u0026quot;DUNSTON, BRYANT\u0026quot;, \u0026quot;DUNSTON, B… ## $ away_player5 \u0026lt;chr\u0026gt; \u0026quot;SIMON, KRUNOSLAV\u0026quot;, \u0026quot;SIMON, KRUNOSLAV\u0026quot;, \u0026quot;SIMON, K… ## $ lineups \u0026lt;chr\u0026gt; \u0026quot;GREEN, ERICK - MELLI, NICOLO - GUDURIC, MARKO - … Más-Menos El más-menos (+/-) mide la diferencia entre los puntos anotados por el equipo y los puntos que permite al equipo rival en el tiempo que uno o más jugadores del equipo están en la pista. getPlusMinus() utiliza los datos jugada a jugada para uno o más partidos y calcula el +/- en cada partido de los jugadores especificados.\nAunque esta estadística está siendo muy usada últimamente, es importante recalcar que el +/- crudo es muy inestable y depende por completo del contexto. Por otro lado, es la pieza clave para construir otras estadísticas más avanzadas como RAPM o RPM.\nDicho esto, vamos a averiguar, por ejemplo, cuál fue el +/- de Sergio Rodriguez en los dos partidos que disputó en la Final Four 2018/2019:\nchacho_pm \u0026lt;- getPlusMinus(pbp = samplepbp, players = \u0026quot;RODRIGUEZ, SERGIO\u0026quot;) # Select only a few columns so that data frame fits in the document chacho_pm %\u0026gt;% select(game_code, team_code_opp, poss, poss_opp, plus_minus) ## # A tibble: 2 x 5 ## game_code team_code_opp poss poss_opp plus_minus ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 258 MAD 44 42 8 ## 2 260 IST 24 25 -10 Nótese que también es posible calcular el más-menos para combinaciones de jugadores introduciendo un vector de caracteres con los nombres de los jugadores como argumento en players.\n Estadísticas On/Off Las estadísticas on/off de un jugador o una combinación de jugadores miden las estadísticas del equipo y del rival cuando ese jugador o jugadores están en pista y cuando están en el banquillo.\nPuedes usar getOnOffStats() para averiguar las estadísticas on/off. Por ejemplo, podemos comparar cómo rindió el Real Madrid cuando Rudy y Ayón estaban en pista y cómo rindió cuando ambos estaban en el banquillo en los dos partidos de la Final Four 2018/2019.\ngetOnOffStats(pbp = samplepbp, players = c(\u0026quot;FERNANDEZ, RUDY\u0026quot;, \u0026quot;AYON, GUSTAVO\u0026quot;)) ## # A tibble: 8 x 28 ## season game_code players on type team_code home fg2a fg2m fg2_pct ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;lgl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;lgl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; ## 1 2018 258 FERNAN… TRUE defe… CSK TRUE 5 1 0.2 ## 2 2018 258 FERNAN… TRUE offe… MAD FALSE 3 2 0.667 ## 3 2018 259 FERNAN… TRUE offe… MAD FALSE 20 14 0.7 ## 4 2018 259 FERNAN… TRUE defe… ULK TRUE 15 7 0.467 ## 5 2018 258 FERNAN… FALSE defe… CSK TRUE 33 16 0.485 ## 6 2018 258 FERNAN… FALSE offe… MAD FALSE 43 22 0.512 ## 7 2018 259 FERNAN… FALSE offe… MAD FALSE 15 9 0.6 ## 8 2018 259 FERNAN… FALSE defe… ULK TRUE 17 9 0.529 ## # … with 18 more variables: fg3a \u0026lt;int\u0026gt;, fg3m \u0026lt;int\u0026gt;, fg3_pct \u0026lt;dbl\u0026gt;, ## # fga \u0026lt;int\u0026gt;, fgm \u0026lt;int\u0026gt;, fg_pct \u0026lt;dbl\u0026gt;, fta \u0026lt;int\u0026gt;, ftm \u0026lt;int\u0026gt;, ## # ft_pct \u0026lt;dbl\u0026gt;, orb \u0026lt;int\u0026gt;, drb \u0026lt;int\u0026gt;, tov \u0026lt;int\u0026gt;, ast \u0026lt;int\u0026gt;, stl \u0026lt;int\u0026gt;, ## # cpf \u0026lt;int\u0026gt;, blk \u0026lt;int\u0026gt;, pts \u0026lt;dbl\u0026gt;, poss \u0026lt;dbl\u0026gt; Nótese que getOnOffStats() genera 4 filas por partido que corresponden a:\n Estadísticas del equipo cuando los jugadores están en pista juntos.\n Estadísitcas del equipo rival cuando los jugadores están en pista juntos.\n Estadísticas del equipo cuando los jugadores están en el banquillo.\n Estadísticas del equipo rival cuando los jugadores están en el banquillo.\n   Patrones de asistencias Los datos jugada a jugada nos permiten averiguar quién asiste a quién en canastas asistidas. La función getAssists() genera un data frame con el pasador y el tirador (junto con más variables) de todas las canastas asistidas en los datos jugada a jugada.\nVoy a usar getAssists() y un poco de manipulación de datos para hayar las asistencias más comunes en el CSK de Moscú en los dos partidos de la Final Four 2018/2019:\nassists_csk \u0026lt;- getAssists(pbp = samplepbp, team = \u0026quot;CSK\u0026quot;) assists_csk %\u0026gt;% count(passer, shooter) %\u0026gt;% arrange(desc(n)) ## # A tibble: 25 x 3 ## passer shooter n ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; ## 1 CLYBURN, WILL HIGGINS, CORY 2 ## 2 DE COLO, NANDO HACKETT, DANIEL 2 ## 3 HACKETT, DANIEL HUNTER, OTHELLO 2 ## 4 RODRIGUEZ, SERGIO HINES, KYLE 2 ## 5 CLYBURN, WILL DE COLO, NANDO 1 ## 6 DE COLO, NANDO CLYBURN, WILL 1 ## 7 DE COLO, NANDO HUNTER, OTHELLO 1 ## 8 DE COLO, NANDO KURBANOV, NIKITA 1 ## 9 DE COLO, NANDO PETERS, ALEC 1 ## 10 HACKETT, DANIEL CLYBURN, WILL 1 ## # … with 15 more rows   Análisis de datos de localización de tiros Los datos de localización de tiros indican las coordenadas x-y de todos los tiros hechos durante un partido. Estos datos pueden ser útiles para, por ejemplo, identificar tendencias en ataque de un jugador o equipo, mostrar qué lugares de la pista un jugador es más efectivo o analizar qué tipo de tiros permite un equipo al rival.\nPara el siguiente análisis voy a usar el conjunto de datos sampleshots que contiene los datos de localización de tiros de los cuatro partidos de la Final Four 2018/2019.\nglimpse(sampleshots) ## Observations: 490 ## Variables: 25 ## $ season \u0026lt;dbl\u0026gt; 2018, 2018, 2018, 2018, 2018, 2018, 2018, 2018, 20… ## $ game_code \u0026lt;int\u0026gt; 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, … ## $ num_anot \u0026lt;int\u0026gt; 5, 6, 10, 14, 16, 18, 21, 25, 27, 30, 31, 33, 34, … ## $ team_code \u0026lt;chr\u0026gt; \u0026quot;ULK\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;… ## $ player_id \u0026lt;chr\u0026gt; \u0026quot;P001324\u0026quot;, \u0026quot;P003048\u0026quot;, \u0026quot;P003048\u0026quot;, \u0026quot;P005159\u0026quot;, \u0026quot;P0018… ## $ player_name \u0026lt;chr\u0026gt; \u0026quot;MUHAMMED, ALI\u0026quot;, \u0026quot;DUNSTON, BRYANT\u0026quot;, \u0026quot;DUNSTON, BRYA… ## $ action_id \u0026lt;chr\u0026gt; \u0026quot;2FGM\u0026quot;, \u0026quot;2FGA\u0026quot;, \u0026quot;2FGM\u0026quot;, \u0026quot;3FGM\u0026quot;, \u0026quot;2FGA\u0026quot;, \u0026quot;2FGA\u0026quot;, \u0026quot;2… ## $ action \u0026lt;chr\u0026gt; \u0026quot;Two Pointer\u0026quot;, \u0026quot;Missed Two Pointer\u0026quot;, \u0026quot;Two Pointer\u0026quot;… ## $ points \u0026lt;int\u0026gt; 2, 0, 2, 3, 0, 0, 0, 3, 0, 3, 0, 3, 3, 2, 2, 2, 0,… ## $ coord_x \u0026lt;dbl\u0026gt; 1.1428571, -0.3163265, -0.1836735, -5.9489796, 1.9… ## $ coord_y \u0026lt;dbl\u0026gt; 2.279082, 2.717857, 2.207653, 6.177041, 2.462755, … ## $ zone \u0026lt;chr\u0026gt; \u0026quot;C\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;H\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;H\u0026quot;, \u0026quot;G\u0026quot;, \u0026quot;I\u0026quot;, … ## $ fastbreak \u0026lt;lgl\u0026gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, T… ## $ second_chance \u0026lt;lgl\u0026gt; FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FA… ## $ off_turnover \u0026lt;lgl\u0026gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, T… ## $ minute \u0026lt;int\u0026gt; 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6,… ## $ console \u0026lt;chr\u0026gt; \u0026quot;09:42\u0026quot;, \u0026quot;09:19\u0026quot;, \u0026quot;09:13\u0026quot;, \u0026quot;08:53\u0026quot;, \u0026quot;08:29\u0026quot;, \u0026quot;08:0… ## $ points_a \u0026lt;int\u0026gt; 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8, 10, 12, … ## $ points_b \u0026lt;int\u0026gt; 0, 0, 2, 2, 2, 2, 2, 5, 5, 8, 8, 11, 11, 13, 15, 1… ## $ utc \u0026lt;chr\u0026gt; \u0026quot;20190517160232\u0026quot;, \u0026quot;20190517160256\u0026quot;, \u0026quot;2019051716030… ## $ make \u0026lt;lgl\u0026gt; TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE… ## $ quarter \u0026lt;int\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… ## $ seconds \u0026lt;dbl\u0026gt; 18, 41, 47, 67, 91, 117, 130, 146, 176, 185, 203, … ## $ team_code_a \u0026lt;chr\u0026gt; \u0026quot;ULK\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;ULK\u0026quot;, \u0026quot;… ## $ team_code_b \u0026lt;chr\u0026gt; \u0026quot;IST\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;IST\u0026quot;, \u0026quot;… Puedes comprobar que además de las coordenadas x-y, coord_x y coord_y, hay variables que dan información contextual como el jugador que realizó el tiro, el tiempo que quedaba en el marcador cuando el tiro ocurrió o si el tiro se hizo tras un rebote ofensivo. Estas variables pueden ayudar a filtrar tiros de características específicas.\nLa función plotShotChart() permite mostrar gráficamente el lugar de la pista en el que se realizaron los tiros, coloreados según se metieron (verde) o se fallaron (rojo). El objeto resultante es un objeto ggplot que podemos modificar con funciones de ggplot2:\nplotShotchart(sampleshots) + labs(title = \u0026quot;Euroleague 2018/2019 Final Four\u0026quot;) + theme(legend.position = \u0026quot;bottom\u0026quot;)  ","date":1574899200,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1574899200,"objectID":"d0a7d3ade0b65faa498d349e003f454a","permalink":"/es/post/2019-11-28-introduction-to-eurolig/introduction-to-eurolig/","publishdate":"2019-11-28T00:00:00Z","relpermalink":"/es/post/2019-11-28-introduction-to-eurolig/introduction-to-eurolig/","section":"post","summary":"Breve introducción a la nueva versión de eurolig para analizar datos jugada a jugada y de localización de tiros para la Euroliga.","tags":["Basketball analytics","R"],"title":"Introducción a eurolig","type":"post"},{"authors":null,"categories":null,"content":"","date":1564610400,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1564610400,"objectID":"e8f5f41e1c192f0130f79202903162ee","permalink":"/es/project/eurolig/","publishdate":"2019-08-01T00:00:00+02:00","relpermalink":"/es/project/eurolig/","section":"project","summary":"Paquete de R para analizar datos de la Euroliga","tags":["statistics","basketball analytics"],"title":"eurolig","type":"project"},{"authors":null,"categories":null,"content":"","date":1563573600,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1563573600,"objectID":"afbb1dbbc5b38c22357d57f95b7d10da","permalink":"/es/project/rfeb/","publishdate":"2019-07-20T00:00:00+02:00","relpermalink":"/es/project/rfeb/","section":"project","summary":"Paquete de R para analizar datos de las ligas de la Federación Española de Baloncesto","tags":["statistics","basketball analytics"],"title":"rfeb","type":"project"},{"authors":null,"categories":["Castellano"],"content":"Introducción eurolig es un paquete de R que he creado para facilitar la obtención y el análisis de datos de partidos de Euroliga. En esta entrada muestro cómo utilizar eurolig para analizar diferentes aspectos de cómo se pasa el balón el FC Barcelona en esta Euroliga 2018-2019. En concreto, estamos interesados en averiguar:\nQué tipo de tiro genera cada jugador cuando da una asistencia\n Cuántos puntos generan las asistencias de cada jugador\n Quién asiste a quién\n Cómo visualizar las asistencias del equipo\n   eurolig El paquete eurolig está en fase experimental y todavía tiene bastantes bugs. En este momento tan solo permite descargar datos jugada-a-jugada pero espero poder incluir la posibilidad de trabajar con otro tipo de datos como la localización de los tiros o estadísticas tradicionales.\nPodéis instalar el paquete desde Github:\n# install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;solmos/eurolig\u0026quot;) Tened en cuenta, sin embargo, que el paquete está en su fase inicial y habrá numerosos cambios con los problemas de reproducibilidad que esto supone. Aún así, descargadlo y jugad con él. Si detectáis algún bug o pensáis en alguna funcionalidad que creáis que pueda ser útil hacédmelo saber.\nPodéis estar al tanto de las novedades del paquete en el archivo NEWS.md del repositorio.\n Análisis Los datos jugada-a-jugada nos permiten saber muchas cosas que no vemos en la tabla de estadísticas convencional. Son este tipo de datos los que nos van a permitir responder a nuestras preguntas sobre las asistencias del FC Barcelona en esta Euroliga.\nObtención de los datos Podemos obtener los datos jugada-a-jugada introduciendo el código del partido/s junto con el año de la temporada correspondiente a la función extract_pbp().\nEl código del partido lo podemos encontrar en la propia URL de la página del partido. Por ejemplo, el último partido que disputó el FC Barcelona en esta Euroliga en el momento de escribir esto fue contra el Bayern de Munich en la ciudad alemana. La URL para este partido en la página oficial es\nhttps://www.euroleague.net/main/results/showgame?gamecode=219\u0026amp;seasoncode=E2018\nObservamos que el código del partido es 219 (gamecode=219). Introduciendo este código junto con el año de inicio de esta temporada en la función extract_pbp() obtenemos los datos jugada-a-jugada de este partido en un data frame:\nlibrary(eurolig) game_pbp \u0026lt;- extract_pbp(game_code = 219, season = 2018) game_pbp ## # A tibble: 518 x 18 ## game_code play_number team_code player_name play_type time_remaining ## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;chr\u0026gt; ## 1 219 2 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; BP 10:00 ## 2 219 3 MUN RADOSEVIC,… TPOFF 09:59 ## 3 219 4 BAR TOMIC, ANTE TPOFF 09:59 ## 4 219 5 BAR RIBAS, PAU 3FGM 09:37 ## 5 219 6 BAR TOMIC, ANTE AS 09:35 ## 6 219 7 MUN LUCIC, VLA… 2FGA 09:20 ## 7 219 8 BAR TOMIC, ANTE D 09:18 ## 8 219 10 BAR PANGOS, KE… 2FGA 08:58 ## 9 219 11 MUN LUCIC, VLA… D 08:55 ## 10 219 12 MUN JOVIC, STE… TO 08:34 ## # … with 508 more rows, and 12 more variables: quarter \u0026lt;fct\u0026gt;, ## # points_home \u0026lt;dbl\u0026gt;, points_away \u0026lt;dbl\u0026gt;, team_name \u0026lt;fct\u0026gt;, ## # player_id \u0026lt;fct\u0026gt;, player_dorsal \u0026lt;dbl\u0026gt;, play_info \u0026lt;chr\u0026gt;, seconds \u0026lt;dbl\u0026gt;, ## # home_team \u0026lt;fct\u0026gt;, away_team \u0026lt;fct\u0026gt;, home \u0026lt;lgl\u0026gt;, season \u0026lt;int\u0026gt; En el presente análisis queremos analizar más de un partido. En concreto, queremos obtener todos los partidos del FC Barcelona en la presente campaña. En lugar de ir buscando en la página web de la Euroliga todos los códigos de los partidos disputados por el FC Barcelona, podemos utilizar la función extract_team_pbp(). Con esta función basta con introducir el código del equipo y el año para obtener todos los partidos que ha disputado ese equipo en esa temporada.\nProcedemos pues a descargar los datos de todos los partidos que ha disputado el actual FC Barcelona hasta la fecha (25 de Marzo del 2019):\npbp \u0026lt;- extract_team_pbp(team = \u0026quot;BAR\u0026quot;, season = 2018) Nótese que lleva un tiempo considerable obtener el data frame final. No es por el tamaño de los datos, ni por falta de optimización del código. La función está diseñada para ser lenta. En la documentación de la API de la Euroliga se indica que dejemos unos segundos entre petición y petición para no saturar el servidor.\n Análisis de asistencias Para averiguar las diferentes preguntas que mencionamos en la introducción echamos mano de la función get_assists(). Introduciendo los datos jugada-a-jugada en esta función obtenemos un data frame con el que luego podremos averiguar muchos detalles interesantes con unas pocas líneas de código. Para ello utilizaremos principalmente el paquete dplyr.\nlibrary(dplyr) assists \u0026lt;- get_assists(pbp, team = \u0026quot;BAR\u0026quot;) assists ## # A tibble: 475 x 12 ## game_code season passer shooter shot_type points time_remaining quarter ## \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;fct\u0026gt; ## 1 2 2018 HEURT… CLAVER… 2FG 1 09:43 1 ## 2 2 2018 CLAVE… TOMIC,… 2FG 2 08:39 1 ## 3 2 2018 HEURT… TOMIC,… 2FG 2 07:44 1 ## 4 2 2018 HEURT… SINGLE… 2FG 2 07:34 1 ## 5 2 2018 CLAVE… SINGLE… 2FG 3 03:19 1 ## 6 2 2018 ORIOL… SERAPH… 2FG 2 00:46 1 ## 7 2 2018 SERAP… KURIC,… 3FG 3 00:13 1 ## 8 2 2018 HEURT… ORIOLA… 2FG 2 07:08 2 ## 9 2 2018 HEURT… SERAPH… 2FG 2 04:58 2 ## 10 2 2018 BLAZI… PUSTOV… 2FG 2 01:17 2 ## # … with 465 more rows, and 4 more variables: seconds \u0026lt;int\u0026gt;, foul \u0026lt;lgl\u0026gt;, ## # and1 \u0026lt;dbl\u0026gt;, ftm \u0026lt;dbl\u0026gt; ¿Qué tipo de tiro genera cada jugador cuando da una asistencia? Con el data frame assists podemos averiguar el tipo de acción con la que culmina la asistencia. Una asistencia puede terminar con un tiro de tres, un tiro de dos, una falta personal de tiro o un tiro de campo más un tiro libre adicional.\nEn este caso, pongamos que estamos interesados solamente en saber si se trata de un tiro de dos o un tiro de tres. Los jugadores del FC Barcelona con más de 10 asistencias en total distribuyen sus asistencias de la siguiente manera:\nassists %\u0026gt;% group_by(passer) %\u0026gt;% summarise( assists = n(), two_pointers = sum(shot_type == \u0026quot;2FG\u0026quot;, na.rm = TRUE), three_pointers = sum(shot_type == \u0026quot;3FG\u0026quot;, na.rm = TRUE), `3pt_ratio` = round(three_pointers / assists, 3) ) %\u0026gt;% arrange(desc(assists)) %\u0026gt;% filter(assists \u0026gt; 10)   passer assists two_pointers three_pointers 3pt_ratio    HEURTEL, THOMAS 138 101 37 0.268  PANGOS, KEVIN 92 55 36 0.391  TOMIC, ANTE 53 34 19 0.358  RIBAS, PAU 47 33 14 0.298  HANGA, ADAM 30 20 10 0.333  SINGLETON, CHRIS 26 15 11 0.423  CLAVER, VICTOR 23 12 11 0.478  KURIC, KYLE 21 13 8 0.381  ORIOLA, PIERRE 15 8 7 0.467  BLAZIC, JAKA 12 9 3 0.250  SERAPHIN, KEVIN 12 8 4 0.333    En este caso Heurtel tiene el segundo menor ratio de asistencias a tiros de tres con respecto al total de asistencias dadas (0.268). Pangos, por otro lado, tiene una proporción bastante mayor de asistencias que van a la línea de tres (0.391).\nLos jugadores grandes y móviles del FC Barcelona, como Claver, Singleton u Oriola, dan una mayor proporción de sus asistencias a tiros de tres.\n ¿Cuántos puntos generan las asistencias de cada jugador? Como hemos visto, no todas las asistencias son iguales. Una asistencia a un tiro de 3 genera dos puntos más que una asistencia que resulta en una falta de tiro en la que el tirador sólo mete un tiro libre.\nCon las siguientes lineas de código podemos calcular cuántos puntos ha generado cada jugador del FC Barcelona con sus asistencias:\nassists %\u0026gt;% group_by(passer) %\u0026gt;% summarise( assists = n(), points = sum(points, na.rm = TRUE), ppa = round(points / assists, 3) ) %\u0026gt;% arrange(desc(assists)) %\u0026gt;% filter(assists \u0026gt; 10)   passer assists points ppa    HEURTEL, THOMAS 138 311 2.254  PANGOS, KEVIN 92 215 2.337  TOMIC, ANTE 53 121 2.283  RIBAS, PAU 47 105 2.234  HANGA, ADAM 30 68 2.267  SINGLETON, CHRIS 26 63 2.423  CLAVER, VICTOR 23 58 2.522  KURIC, KYLE 21 48 2.286  ORIOLA, PIERRE 15 36 2.400  BLAZIC, JAKA 12 26 2.167  SERAPHIN, KEVIN 12 28 2.333    La última columna de esta tabla (ppa) nos da los puntos por asistencia que genera cada jugador (con más de 10 asistencias). Vemos que Claver y Singleton generan el máximo valor por asistencia, dado que un porcentaje relativamente alto de sus asistencias son a tiros de tres puntos.\n ¿Quién pasa a quién? También es posible hayar a quién han ido dirigidas las asistencias de cada jugador del FC Barcelona. A continuación se muestran las 10 combinaciones pasador-tirador más comunes en lo que llevamos de temporada:\nassists %\u0026gt;% group_by(passer, shooter) %\u0026gt;% count() %\u0026gt;% arrange(desc(n)) %\u0026gt;% head(10)   passer shooter n    HEURTEL, THOMAS SERAPHIN, KEVIN 27  HEURTEL, THOMAS TOMIC, ANTE 24  PANGOS, KEVIN TOMIC, ANTE 22  HEURTEL, THOMAS ORIOLA, PIERRE 21  HEURTEL, THOMAS SINGLETON, CHRIS 17  PANGOS, KEVIN KURIC, KYLE 16  PANGOS, KEVIN SERAPHIN, KEVIN 15  TOMIC, ANTE SINGLETON, CHRIS 15  HEURTEL, THOMAS CLAVER, VICTOR 12  HEURTEL, THOMAS KURIC, KYLE 12    Las cinco combinaciones más comunes son entre base y pivot. Observamos que Heurtel se entiende muy bien con los interiores de su equipo, especialmente los dos cincos, Seraphin y Tomic. Esto explica la baja proporción de asistencias a tiros de tres que obervamos anteriormente.\nAlgo que debemos tener en cuenta, sin embargo, es la cantidad de minutos que estas parejas de jugadores están juntas en la cancha. Este dato permitiría tener una medida ajustada y nos permitiría identificar posibles mejoras en los quintetos que tiene en pista el equipo.\n Cómo visualizar las asistencias del equipo Es posible resumir algunos de los datos que hemos obtenido anteriormente mediante un heatmap que muestre la distribución de las asistencias. Para ello hacemos uso de la función plot_heatmap():\nplot_heatmap(pbp, \u0026quot;BAR\u0026quot;) + ggplot2::labs( title = \u0026quot;Patrón de asistencias del FC Barcelona\u0026quot;, subtitle = \u0026quot;Euroliga 2018-2019 (primeros 28 partidos)\u0026quot;, x = \u0026quot;Tirador\u0026quot;, y = \u0026quot;Pasador\u0026quot;) El eje vertical representa al pasador mientras que el eje horizontal representa al jugador que tira tras el pase. La diagonal de este heatmap contiene el número total de asistencias de cada jugador. El color indica el número de asistencias que un jugador ha dado a otro jugador.\n   ","date":1553731200,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1553731200,"objectID":"41205b9df071831f2beeae636183cdc5","permalink":"/es/post/2019-03-28-eurolig/analisis-asistencia/","publishdate":"2019-03-28T00:00:00Z","relpermalink":"/es/post/2019-03-28-eurolig/analisis-asistencia/","section":"post","summary":"Cómo usar el paquete eurolig para analizar los patrones de asistencias del FC Barcelona en esta temporada de Euroliga","tags":["Baloncesto","Estadística avanzada","R"],"title":"Análisis de los patrones de asistencias del FC Barcelona en Euroliga","type":"post"},{"authors":null,"categories":["Castellano"],"content":"Échale un ojo a la siguiente secuencia de números:\n\\[0, 1, 3, 6, 2, 7, 13, 20, 12, 21, 11, 22, \\ldots\\]\nSi no la has visto nunca, seguramente no consigas averiguar qué patrón sigue esta secuencia. Se trata de la llamada secuencia de Recamán, atribuída al matemático colombiano Bernardo Recamán.\nA pesar de su aparente complejidad, las reglas para generar esta secuencia son más bien sencillas. Lo mejor para comprender el algoritmo que genera esta secuencia es dibujar una línea que vaya desde 0 hasta, por ejemplo, 7 para empezar: Básicamente se trata de, empezando desde el \\(0\\), en cada paso intentamos ir hacia la izquierda un número de unidades igual al paso en el que nos encontramos. Si el número en el que caemos al ir a la izquierda está a la izquierda de \\(0\\) o ya ha aparecido en nuestra secuencia anteriormente, en lugar de ir a la izquierda vamos a la derecha.\nEl escritor Alex Bellos lo explica mucho mejor en el siguiente vídeo de Numberphile:   Implementación en R Para esta entrada he utilizado R para generar y dibujar la secuencia de Recamán. En unas pocas líneas de código podemos crear una función que genere un número determinado de elementos de esta secuencia:\n# Generar los primeros n números de la secuencia de Recamán get_recaman \u0026lt;- function(n) { recaman_seq \u0026lt;- numeric(n) for (i in 1:length(recaman_seq)) { candidate \u0026lt;- recaman_seq[i] - i if (candidate \u0026gt; 0 \u0026amp; !(candidate %in% recaman_seq)) { recaman_seq[i + 1] \u0026lt;- candidate } else recaman_seq[i + 1] \u0026lt;- recaman_seq[i] + i } recaman_seq \u0026lt;- recaman_seq[-length(recaman_seq)] recaman_seq } get_recaman(20) ## [1] 0 1 3 6 2 7 13 20 12 21 11 22 10 23 9 24 8 25 43 62 Para dibujar la secuencia utilizamos semicírculos que representen los saltos de un número al otro.\nPuedes obtener el código para dibujar la secuencia aquí.\n Explorando el camino de Recamán Juega con el código y explora la secuencia. ¿Crees que tarde o temprano aparecen todos los números enteros? Se conjetura que no, que existen ciertos agujeros en el camino de Recamán.\n¿No hay algo extraño en esta secuencia?\n ","date":1550620800,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1550620800,"objectID":"fa00b4a27e3eb0b40d31930f3dc2e2e1","permalink":"/es/post/2019-02-20-la-secuencia-de-recaman/la-secuencia-de-recaman/","publishdate":"2019-02-20T00:00:00Z","relpermalink":"/es/post/2019-02-20-la-secuencia-de-recaman/la-secuencia-de-recaman/","section":"post","summary":"Cómo generar y dibujar la misteriosa secuencia de Recamán con R","tags":["Matemáticas","R","Arte generativo"],"title":"La secuencia de Recamán","type":"post"},{"authors":null,"categories":["Castellano"],"content":"Kirk Goldsberry es una de las figuras más destacadas en el mundo de la estadística avanzada en la NBA. Se le conoce principalmente por el uso de gráficos de tiro en sus análisis. Este es un ejemplo en el que se muestran todos los tiros que ha realizado Lebron James a lo largo de su carrera:\nHappy Birthday, LeBron His constellation so far... pic.twitter.com/4HuCjTgl4x\n\u0026mdash; Kirk Goldsberry (@kirkgoldsberry) December 30, 2018  Los gráficos de tiro pueden ser útiles para, por ejemplo, identificar tendencias en ataque de un determinado jugador/equipo, mostrar en qué zonas del campo un jugador es más efectivo o analizar qué tipo de tiros un equipo permite al rival.\nLa liga en la que juego, la LEB Oro, proporciona gráficos de tiro en la plataforma Baloncesto en Vivo. Para esta entrada he creado un paquete de R, rfeb, con el que poder extraer las coordenadas de los tiros de esta página web para luego obtener gráficos de tiro del partido o partidos que queramos.\nDicho esto, por alguna extraña razón, la plataforma Baloncesto en Vivo no ofrece ningún menú de selección para acceder a las estadísticas de partidos de jornadas anteriores (o temporadas anteriores). Tan solo son visibles los partidos de la jornada más reciente.\nEs posible acceder a partidos anteriores sabiendo el identificador del partido y añadiéndolo a la url base (http://baloncestoenvivo.feb.es/Game/). Sin embargo, al parecer se van eliminando los datos a medida que avanzan las jornadas. Según escribo esta entrada sólo es posible acceder a los partidos disputados después de la jornada 13 de esta temporada.\nAdemás de esta incomprensible limitación, la recogida de datos parece poco fiable. Según he podido comprobar, varias canchas de la competición producen gráficos de tiro que obviamente no son correctos.\nHuesca y Real Canoe son los principales sospechosos. He encontrado varios casos pero mirad, por ejemplo, el partido en la pista del ZTE Real Canoe donde según el gráfico de tiro no se hizo ningún tiro dentro de la zona por parte de ninguno de los dos equipos… Hasta que este tipo de errores no se eliminen, cualquier análisis con estos datos será de dudosa validez.\nGráficos de tiro rfeb es un paquete de R que he creado para trabajar con datos disponibles en Baloncesto en Vivo. rfeb contiene dos funciones principales:\n extract_shots(): Extrae los datos de tiro de Baloncesto en Vivo de los identificadores de partido que introducimos\n plot_shotchart(): Crea gráficos de tiro con los datos que introducimos\n  Puedes instalar rfeb de la siguiente manera:\n# install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;solmos/rfeb\u0026quot;) Puedes echarle un ojo al código de estas funciones aquí. Nótese que aunque en este caso extraeré datos de la LEB Oro, también sería posible trabajar con datos de las otras competiciones FEB disponibles en Baloncesto en Vivo.\nA continuación voy a mostrar, utilizando rfeb, cómo obtener gráficos de tiro de todos los partidos de la última jornada de la primera vuelta de la LEB Oro disputada el fin de semana del 11/01/2019.\nLos identificadores de los partidos en este caso van desde el 2010208 al 2010216. Usamos extract_shots() para obtener los datos recogidos de los tiros que se hicieron en estos partidos. Obtenemos un data frame en el que cada fila representa un tiro, de los cuales se muestran las siguientes variables:\n t = Tiempo desde el comienzo del partido\n x, y = Coordenadas del tiro\n team = Equipo del jugador que realizó el tiro\n player = Dorsal del jugador que realizó el tiro\n quarter = Cuarto en el que se realizó el tiro\n game = Identificador del partido\n made = Tiro fallado (Missed) o metido (Made)\n  library(rfeb) game_ids \u0026lt;- 2010208:2010216 shots \u0026lt;- extract_shots(game_ids) head(shots) ## t x y team player quarter game made ## 1 00:39 715.20 833.85 SÁENZ HORECA ARABERRI 3 1 2010208 Missed ## 2 00:47 824.20 245.25 LEYMA CORUÑA 22 1 2010208 Made ## 3 01:23 1069.45 485.05 LEYMA CORUÑA 4 1 2010208 Missed ## 4 01:35 628.00 523.20 SÁENZ HORECA ARABERRI 10 1 2010208 Missed ## 5 01:43 72.10 283.40 SÁENZ HORECA ARABERRI 3 1 2010208 Missed ## 6 01:48 687.95 207.10 LEYMA CORUÑA 1 1 2010208 Made Una vez tenemos los datos de los tiros, usamos la función plot_shotchart() para visualizar el gráfico de tiro. La función usa ggplot2 para producir el gráfico y es posible especificar los argumentos que queremos para el mapping de la función geom_point(). Por ejemplo, podemos elegir el color de los puntos según fueron o no canasta.\nA continuación muestro todos los tiros de la jornada en un sólo gráfico:\nplot_shotchart(shots, color = made) Seguramente no querramos mostrar todos los tiros. Es posible usar otras funciones de ggplot2 para adaptar el gráfico a nuestras necesidades. Por ejemplo, podemos usar facet_wrap() para obtener una matriz de gráficos según el partido:\nlibrary(ggplot2) plot_shotchart(shots, color = made) + facet_wrap(~ game) Por último, utilizaremos dplyr para filtrar los tiros que queremos mostrar. Digamos que quiero ver qué tiros hice yo en el partido que disputé contra Palencia en esta jornada. Este partido se corresponde con el identificador 2010215 y el número que llevo en mi camiseta es el 41:\nlibrary(dplyr) shots %\u0026gt;% filter(game == 2010215 \u0026amp; team == \u0026quot;COVIRAN GRANADA\u0026quot; \u0026amp; player == \u0026quot;41\u0026quot;) %\u0026gt;% plot_shotchart(color = made) + ggtitle(\u0026quot;Sergio Olmos vs. Palencia\u0026quot;) rfeb todavía está en proceso de desarrollo. Mi idea es ampliar la funcionalidad de este paquete para poder analizar no solo datos de tiro, sino también datos jugada-a-jugada. Escribiré más entradas en el blog a medida que vaya añadiendo más funciones al paquete.\n Recursos adicionales  Web Scraping 201: finding the API\n Getting started with httr\n Drawing a basketball court with R\n   ","date":1548288000,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1548288000,"objectID":"d25eb34c63816b606cbbed1fbbfba14b","permalink":"/es/post/2019-01-24-graficos-de-tiro-con-r/shotcharts-with-r/","publishdate":"2019-01-24T00:00:00Z","relpermalink":"/es/post/2019-01-24-graficos-de-tiro-con-r/shotcharts-with-r/","section":"post","summary":"Cómo obtener gráficos de tiro de la liga LEB Oro usando el paquete rfeb","tags":["R","Baloncesto"],"title":"rfeb: Gráficos de tiro con R","type":"post"},{"authors":null,"categories":["English"],"content":"I was reading about the Hidden beauty of multiplication tables and I thought it could be fun to make some of the cool plots in that article with R.\nAs I was trying to visualize new patterns in the multiplication table, I ended up with some useful fuctions that I decided to put in a simple R package called multable that you can install from GitHub.\nThe multiplication table Consider the standard \\(10 \\times 10\\) multiplication table, with the first row and the first column taking the values \\(1\\) through \\(10\\), forming a grid with the corresponding products.\nlibrary(tidyverse) # Data frame with all the values of the 10x10 multiplication table multiplication_table \u0026lt;- tibble( x = 1:10, y = 1:10 ) %\u0026gt;% # Get all combination of x and y complete(x, y) %\u0026gt;% # Get the product of all combinations mutate(product = x * y) ggplot(multiplication_table, aes(x, y)) + geom_tile(color = \u0026quot;white\u0026quot;) + geom_text(aes(label = product), color = \u0026quot;white\u0026quot;) + # We want the table to start with 1 in the upper-left corner scale_y_continuous(trans = \u0026quot;reverse\u0026quot;) + # We want to always display the tables as squares coord_fixed() + theme_void() For purposes that we will see next, I am going to add a row and a column of zeros above and to the left of our table, respectively:\nmultiplication_table \u0026lt;- tibble( x = 0:10, y = 0:10 ) %\u0026gt;% complete(x, y) %\u0026gt;% mutate(product = x * y) ggplot(multiplication_table, aes(x, y)) + geom_tile(color = \u0026quot;white\u0026quot;) + geom_text(aes(label = product), color = \u0026quot;white\u0026quot;) + scale_y_continuous(trans = \u0026quot;reverse\u0026quot;) + coord_fixed() + theme_void() Next, we will discover some beautiful symmetries by coloring the rectangles of the multiplication table that correspond to multiples of a number \\(k\\) for various values of \\(k\\).\n Single multiples We say that \\(c\\) is a multiple of \\(k\\) if \\(c = n k\\) for some integer \\(n\\), which is called the multiplier. So we can tell if a given number \\(c\\) is a multiple of \\(k\\) if the division \\(c\\) over \\(k\\) has remainder 0.\nLet’s begin with \\(k = 2\\). I am going to color the cells corresponding to multiples of \\(2\\) in one color and non-multiples of \\(2\\) in another color. Check out the pattern it emerges:\nlibrary(wesanderson) m2 \u0026lt;- multiplication_table %\u0026gt;% mutate(multiple_of_2 = product %% 2 == 0) # Color palette chosen from the wesanderson package colors \u0026lt;- wes_palette(name = \u0026quot;Zissou1\u0026quot;, n = 2) ggplot(m2, aes(x, y)) + geom_tile(aes(fill = multiple_of_2), color = \u0026quot;white\u0026quot;) + geom_text(aes(label = product), color = \u0026quot;white\u0026quot;) + scale_y_continuous(trans = \u0026quot;reverse\u0026quot;) + coord_fixed() + scale_fill_manual(values = colors, name = \u0026quot;Multiple of 2?\u0026quot;, labels = c(\u0026quot;No\u0026quot;, \u0026quot;Yes\u0026quot;)) + theme_void() If we look closely we can see that the whole pattern above can be pieced together using the following fundamental block:\nblock_2 \u0026lt;- tibble( x = c(0,1), y = c(0,1) ) %\u0026gt;% complete(x, y) %\u0026gt;% distinct() %\u0026gt;% mutate(product = x * y, multiple = product %% 2 == 0) ggplot(block_2, aes(x, y)) + geom_tile(aes(fill = multiple), color = \u0026quot;white\u0026quot;) + scale_y_continuous(trans = \u0026quot;reverse\u0026quot;) + scale_fill_manual(values = colors, guide = FALSE) + theme_void() As Zoheir Barka explains in his article mentioned at the beginning, the fundamental building block contains \\(k \\times k = 2 \\times 2 = 4\\) cells of the multiplication table. The fact that, in the case of a single multiple, each side of the fundamental building block is \\(k\\) can be useful when plotting our tables.\nWe want to explore the patterns for different values of \\(k\\) so I created a simple function that plots a colored multiplication table for the supplied \\(k\\) and the supplied dimensions. Multiples and non-multiples are colored the same way as before so I chose to drop the legend for aesthetic reasons.\n# Auxiliary function to create a data frame # with the values of the multiplication table create_mtable \u0026lt;- function(xmax, ymax) { data.frame( x = 0:xmax, y = 0:ymax ) %\u0026gt;% complete(x, y) %\u0026gt;% mutate(product = x * y) } # Plot the colored table draw_pattern \u0026lt;- function(k, xmax, ymax) { # Colors chosen from the Zissou1 palette in the wesanderson package colors \u0026lt;- wesanderson::wes_palette(name = \u0026quot;Zissou1\u0026quot;, n = 2) tab \u0026lt;- create_mtable(xmax, ymax) %\u0026gt;% mutate(multiple = product %% k == 0) %\u0026gt;% ggplot(aes(x, y)) + geom_tile(aes(fill = multiple), color = \u0026quot;white\u0026quot;) + geom_text(aes(label = product), color = \u0026quot;white\u0026quot;) + scale_y_continuous(trans = \u0026quot;reverse\u0026quot;) + coord_fixed() + scale_fill_manual(values = colors) + theme_void() + guides(fill = FALSE) tab } We can now easily plot the colored tables for different values of \\(k\\) and see what patterns emerge:\ndraw_pattern(k = 4, xmax = 4 * 3, ymax = 4 * 3) + labs(title = \u0026quot;Multiples of 4\u0026quot;) draw_pattern(6, 6 * 2, 6 * 2) + labs(title = \u0026quot;Multiples of 6\u0026quot;) Notice that we set the “length” of each side of the tables to multiples of \\(k\\) so that the pattern is symmetric.\n Multiple multiples We can plot more interesting (and beautiful) patterns if we use multiple multiples, and corresponding to them, multiple colors.\nConsider the multiples of \\(k_1 = 2\\) and \\(k_2 = 3\\). I will color each square of the multiplication table according to the following criteria:\n Not multiple of neither 2 nor 3\n Multiple only of 2\n Multiple only of 3\n Multiple of both 2 and 3\n  multiple_multiples \u0026lt;- tibble( x = 0:12, y = 0:12 ) %\u0026gt;% complete(x, y) %\u0026gt;% mutate(product = x * y, m2 = product %% 2 == 0, m3 = product %% 3 == 0, inter = interaction(m2, m3)) %\u0026gt;% mutate(interaction = recode_factor(inter, FALSE.FALSE = \u0026quot;Multple of neither\u0026quot;, TRUE.FALSE = \u0026quot;Multiple of 2\u0026quot;, FALSE.TRUE = \u0026quot;Multiple of 3\u0026quot;, TRUE.TRUE = \u0026quot;Multiple of both\u0026quot;)) ggplot(multiple_multiples, aes(x, y)) + geom_tile(aes(fill = interaction), color = \u0026quot;white\u0026quot;) + geom_text(aes(label = product), color = \u0026quot;white\u0026quot;) + scale_fill_brewer(palette = \u0026quot;Pastel1\u0026quot;, name = element_blank()) + scale_y_continuous(trans = \u0026quot;reverse\u0026quot;) + coord_fixed() + theme_void() Notice that I used a \\(12 \\times 12\\) table so that I got a symmetric pattern. I did this because I knew that the fundamental building block is given by the least common multiple of \\(2\\) and \\(3\\). That is, in this case the fundamental block consists of \\(6 \\times 6 = 36\\) little cells.\n multable package I have created a simple R package out of this idea of coloring the factors of different numbers, called multable. You can install it with\n# install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;solmos/multable\u0026quot;) As of now, the package contains just two functions:\n create_table() generates a data frame with the grid values and identifies the factors for different values of k\n draw_pattern() plots the multiplication table coloring the different cells according to what value of k a given cell is a factor of\n  Check out the code for these functions here. My plan is to add more functionality to this package but you can actually do some pretty cool visualizations as it is.\n  ","date":1541462400,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1541462400,"objectID":"081c8eb970dda2b9f586850f1728e85b","permalink":"/es/post/2018-11-06-multiplication-table/multiplication-table-with-r/","publishdate":"2018-11-06T00:00:00Z","relpermalink":"/es/post/2018-11-06-multiplication-table/multiplication-table-with-r/","section":"post","summary":"I show how to visualize the patterns that emerge in the multiplication table and present an R package I created for this purpose","tags":["R","Mathematics"],"title":"Exploring the multiplication table with R","type":"post"},{"authors":null,"categories":null,"content":"","date":1461708000,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1461708000,"objectID":"ab9d6b8d5274fb7e7927b1fc60f36192","permalink":"/es/project/tfm/","publishdate":"2016-04-27T00:00:00+02:00","relpermalink":"/es/project/tfm/","section":"project","summary":"Analysis of clustered data using linear mixed models","tags":["statistics","linear mixed models","multilevel models","hierarchical models"],"title":"Trabajo Fin de Máster","type":"project"}]